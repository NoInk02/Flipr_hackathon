{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack://[project]/middleware.ts"],"sourcesContent":["// import { NextResponse } from 'next/server';\n// import { getToken } from 'next-auth/jwt';\n// import type { NextRequest } from 'next/server';\n\n// export async function middleware(request: NextRequest) {\n//   const { pathname } = request.nextUrl;\n//   const token = await getToken({ req: request, secret: process.env.NEXTAUTH_SECRET });\n\n//   // Define protected routes and their required roles\n//   const protectedRoutes: { [key: string]: string } = {\n//     '/admin': 'Admin',\n//     '/client': 'Client',\n//     '/agent': 'Agent',\n//   };\n\n//   // Public routes that authenticated users should not access\n//   const publicRoutes = ['/', '/signin', '/register'];\n//   const isPublicRoute = publicRoutes.includes(pathname);\n\n//   // Skip middleware for auth-related routes and static files\n//   if (\n//     pathname.startsWith('/api/auth') || \n//     // pathname === '/signin' ||\n//     pathname.startsWith('/_next') ||\n//     pathname.includes('.')\n//   ) {\n//     return NextResponse.next();\n//   }\n\n//   // Check if the requested path is protected\n//   const isProtectedRoute = Object.keys(protectedRoutes).some((route) =>\n//     pathname.startsWith(route)\n//   );\n\n//   // Handle authenticated users\n//   if (token) {\n//     const userRole = token.type as string;\n//     const username = token.name as string;\n\n//     // Map roles to their base dashboard paths\n//     const roleDashboards: { [key: string]: string } = {\n//       Admin: `/admin/${username}/`,\n//       Client: `/client/${username}/`,\n//       Agent: `/agent/${username}/`,\n//     };\n\n//     const userDashboard = roleDashboards[userRole];\n\n//     // Check if user is already on their dashboard\n//     const isOnDashboard = pathname.startsWith(`/${userRole.toLowerCase()}/${username}`);\n\n//     // Only redirect if:\n//     // 1. User is on a public route\n//     // 2. User is trying to access a different role's route\n//     // 3. User is on the base role route (e.g., /admin) but not their dashboard\n//     if (\n//       (isPublicRoute && !isOnDashboard) || \n//       (isProtectedRoute && !isOnDashboard && protectedRoutes[pathname.split('/')[1]] !== userRole)\n//     ) {\n//       return NextResponse.redirect(new URL(userDashboard, request.url));\n//     }\n\n//     // Check if user has the correct role for the protected route\n//     if (isProtectedRoute && !isOnDashboard) {\n//       const requiredRole = Object.entries(protectedRoutes).find(([route]) =>\n//         pathname.startsWith(route)\n//       )?.[1];\n\n//       if (requiredRole && userRole !== requiredRole) {\n//         return NextResponse.redirect(new URL('/not-found', request.url));\n//       }\n//     }\n//   } else if (isProtectedRoute) {\n//     // Redirect unauthenticated users to sign-in\n//     const signInUrl = new URL('/signin', request.url);\n//     // signInUrl.searchParams.set('callbackUrl', pathname);\n//     // signInUrl.searchParams.set('error', 'Please login');\n//     return NextResponse.redirect(signInUrl);\n//   }\n\n//   // Allow the request to proceed if all checks pass\n//   return NextResponse.next();\n// }\n\n// // Apply middleware to protected routes and public routes\n// export const config = {\n//   matcher: ['/admin/:path*', '/client/:path*', '/agent/:path*', '/', '/signin', '/register'],\n// };\n\nimport { NextResponse } from 'next/server';\nimport { getToken } from 'next-auth/jwt';\nimport type { NextRequest } from 'next/server';\n\n// Check if a route is public (no authentication required)\nfunction isPublicRoute(pathname: string): boolean {\n  // Match dynamic public routes for clients and agents\n  if (pathname.match(/^\\/company\\/[^\\/]+\\/(clientlogin|clientregister|agentlogin)$/)) {\n    return true;\n  }\n  return false;\n}\n\n// Get the user's dashboard route based on their role and token data\nfunction getDashboardRoute(token: any): string {\n  const role = token.type as string;\n  const username = token.name as string;\n  const companyId = token.company_id as string;\n\n  if (role === 'Admin') {\n    return `/admin/${username}`;\n  } else if (role === 'client') {\n    return `/company/${companyId}/client/${username}`;\n  } else if (role === 'helper') {\n    return `/company/${companyId}/agent/${username}`;\n  }\n  return '/';\n}\n\n// Check if the user has access to the requested route\nfunction hasAccess(pathname: string, token: any): boolean {\n  const role = token.type as string;\n  const username = token.name as string;\n  const companyId = token.company_id as string;\n\n  if (role === 'Admin') {\n    return pathname.startsWith('/admin/');\n  } else if (role === 'client') {\n    // Match both base client routes and ticket routes\n    const match = pathname.match(/^\\/company\\/([^\\/]+)\\/client\\/([^\\/]+)(?:\\/[^\\/]+)?$/);\n    if (match) {\n      const pathCompanyId = match[1];\n      const pathClientId = match[2];\n      return pathCompanyId === companyId && pathClientId === username;\n    }\n  } else if (role === 'helper') {\n    const match = pathname.match(/^\\/company\\/([^\\/]+)\\/agent\\/([^\\/]+)/);\n    if (match) {\n      const pathCompanyId = match[1];\n      const pathAgentId = match[2];\n      return pathCompanyId === companyId && pathAgentId === username;\n    }\n  }\n  return false;\n}\n\nexport async function middleware(request: NextRequest) {\n  const { pathname } = request.nextUrl;\n  const token = await getToken({ req: request, secret: process.env.NEXTAUTH_SECRET });\n\n  // Skip middleware for auth-related routes and static files\n  if (\n    pathname.startsWith('/api/auth') ||\n    pathname.startsWith('/_next') ||\n    pathname.includes('.')\n  ) {\n    return NextResponse.next();\n  }\n\n  const isPublic = isPublicRoute(pathname);\n\n  if (token) {\n    const dashboardRoute = getDashboardRoute(token);\n\n    // Redirect authenticated users from public routes to their dashboard\n    if (isPublic) {\n      return NextResponse.redirect(new URL(dashboardRoute, request.url));\n    }\n\n    // For admin routes, only check if the user is an admin\n    if (pathname.startsWith('/admin/') && token.type !== 'Admin') {\n      return NextResponse.redirect(new URL('/not-found', request.url));\n    }\n\n    // For other protected routes, check access\n    if (!pathname.startsWith('/admin/') && !hasAccess(pathname, token)) {\n      return NextResponse.redirect(new URL('/not-found', request.url));\n    }\n  } else if (!isPublic) {\n    // Redirect unauthenticated users to sign-in for protected routes\n    const signInUrl = new URL('/signin', request.url);\n    return NextResponse.redirect(signInUrl);\n  }\n\n  return NextResponse.next();\n}\n\n// Define the routes to apply the middleware to\nexport const config = {\n  matcher: [\n    '/admin/:path*',\n    '/company/:companyid/client/:clientid/:path*',\n    '/company/:companyid/agent/:agentid/:path*',\n    '/company/:companyid/clientlogin',\n    '/company/:companyid/clientregister',\n    '/company/:companyid/agentlogin',\n  ],\n};"],"names":[],"mappings":"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"}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}